

# 类和动态内存分配

## `StringBad`类的编写

| code-list-12-01                                     | code-list-12-02                                         | code-list-12-03                                       |
| --------------------------------------------------- | ------------------------------------------------------- | ----------------------------------------------------- |
| [strngbad.h](./examples/code-list-12-01-strngbad.h) | [strngbad.cpp](./examples/code-list-12-02-strngbad.cpp) | [vegnews.cpp](./examples/code-list-12-03-vegnews.cpp) |

该案例涉及了类的静态成员和动态内存分配的编写。

## 类的静态成员

### 静态数据成员

### 静态成员函数

### 静态成员在应用中的特点

## 类的动态内存分配

### 指针形式的数据成员

### new初始化问题

### 存储回收问题

### 类对象的基本操作问题

## 类内的特殊成员

C++类中，如果用户没有自定义下面这些成员函数，C++将自动提供。

| 特殊成员函数   | 描述        |
| -------------- | ----------- |
| 默认构造函数   |             |
| 默认析构函数   |             |
| 复制构造函数   |             |
| 赋值运算符     |             |
| 地址运算符     |             |
| 移动构造函数   | C++11中出现 |
| 移动赋值运算符 | C++11中出现 |

### 默认构造函数





### 默认析构函数

在变量离开作用域时被自动调用。

### 复制构造函数

复制构造函数用于将一个对象复制到**新创建**的对象中。类的复制构造函数原型通常如下：

```
Class_name(const Class_name&);
```

==那么何时将会调用复制构造函数呢？==

新建一个对象并将其初始化为同类现有对象时，复制构造函数将被调用，下面4中声明都将调用复制构造函数`Class_name(const Class_name&)`：

```
Class_name variable1(variable_known);
Class_name variable2 = variable_known;
Class_name variable3 = StringBad(variable_known);
Class_name * p_class = new Class_name(variable_known); 
```

当程序生成了对象副本时，复制构造函数将被调用。具体说，当函数按值传递对象或按值返回对象时，都将使用复制构造函数。

==那么默认复制构造函数将会进行何种程度的复制呢？==

默认的复制构造函数是一种浅复制，逐个复制非静态成员的值，静态成员不受影响。如下图所示。

<img src="./assets/特殊类方法_复制构造函数.png" style="zoom: 25%;" />

如上图所示，默认复制构造函数的浅复制方式可能会带来数据受损，重复删除的问题。如下部分代码所示。

```
int main()
{
	...
	callme2(v1);
	...
}

void callme2(StringBad v2)
{
	cout << "String passed by value:\n";
	cout << " \"" << v2 << "\"\n";
}
```

 `void callme2(StringBad sb)`此函数为按值传递。若类未定义复制构造函数，那么`v2`将使用类默认的复制构造函数进行浅复制。默认的复制构造函数不会对静态成员变量加1，同时对于其中的指针成员，`v1`和`v2`将指向同一块内存，如上图所示。当函数接近尾声，`v2`的作用域到此为止，将会调用`v2`的析构函数释放`v2`，同时由于`v2`中的指针对象和`v1`中的指针对象指向同一块内存，当`v2`被释放，`v1`中指针成员指向的内存被`v2`的析构函数一并释放了，导致数据丢失，以及当`v1`结束时`v1`的析构函数会对该内存再次释放，导致重复内存空间重复释放。

==如何解决默认复制构造函数浅复制带来的问题呢？==

<img src="./assets/特殊类方法_复制构造函数_深复制.png" style="zoom: 25%;" />

在自定义的默认复制构造函数中使用深复制（deep copy）。深复制是与浅复制相对的一种复制方法。在复制指针对象时，应当将指针指向的内容复制给另一个对象，并为此创建一个新的地址。这样每个对象自己的成员都是相对独立的，而不是引用另一个对象的成员。那么在调用析构函数时，将依次释放不同的成员，不会错误地释放其他类对象的成员。

```
StringBad::StringBad(const StringBad& st)
{
	num_strings++;
	len = st.len; // 非指针成员正常复制
	str = new char[len + 1]; // 指针成员新建一份地址
	std::strcpy(str, st.str); // 指针成员对字符串进行复制
	cout << nuim_strings << ": \"" << str << "\"object created.\n";
}
```

### 默认赋值运算符

C++允许类对象赋值，这是通过自动为类重载运算符实现的。这种运算符的原型如下：

```
Class_name & Class_name::operator=(const Class_name &);
```

它接受并返回一个指向类对象的引用。

==那么何时以及如何使用赋值运算符呢？==

在将已有对象赋给另一个对象时，将使用重载的赋值运算符。初始化对象不一定会使用赋值运算符。

与构造复制函数类似，赋值元素安抚的隐式实现也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。

==以及使用赋值运算符时，会产生哪些问题呢？==

默认的赋值运算符和默认的复制构造函数类似，都是一种浅复制。从而导致类似的数据受损，内存空间重复释放的问题。

==如何解决赋值运算符产生的问题呢？==

同样，默认的赋值赋值运算符都是浅复制，需要定义一种深复制的赋值方式，与定义复制构造函数相似，但也有些不同。

* 由于目标对象可能引用了之前分配的数据，所以函数应当使用delete[]来释放这些数据。
* 函数应当尽量避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容。
* 函数返回一个指向调用对象的引用。

通过返回一个对象，函数可以像常规赋值操作那样，连续进行赋值。

```
StringBad & StringBad::operator = (const StringBad & st)
{
	if (this = &st);
		return *this;
// 首先进行自我复制，查看赋值运算符右边的地址是否与接受对象的地址相同
// 若相同，则直接返回*this，然后结束
	delete [] str;
// 如果地址不同，函数将释放str指向的内存，这是因为稍后将把一个新字符串的地址赋给str。
// 如果不首先使用delete运算符，则上述字符串将保留在内存中。由于程序中不在包含指向这块旧内存的指针，因此导致内存浪费
	len = st.len;
	str = new char [len + 1];
// 与自定义复制构造函数相似，即为新字符串分配足够的内存空间，然后将赋值运算符右边的对象中的字符串赋值到新的内存单元中
	std::strcpy(str, st.str);
	return * this;
// 返回解除引用后的指针
// 赋值操作并不创建新的对象
}
```

## `StringBad`类改进为`String`类

经过上述补充后，可以对`StringBad`类进行改进，改进后的文件如下：

| code-list-12-04                                   | code-list-12-05                                       | code-list-12-06                                         |
| ------------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------- |
| [string1.h](./examples/code-list-12-04-string1.h) | [string1.cpp](./examples/code-list-12-05-string1.cpp) | [sayings1.cpp](./examples/code-list-12-06-sayings1.cpp) |

在原有的基础上，需要进行**修改**。首先，添加自定义的复制构造函数和赋值运算符，将浅拷贝修正为深拷贝；其次，使类构造函数和析构函数保持沉默；最后，简化默认构造函数，使之创建一个空字符。

接下来，需要再**添加**一些新内容。添加的新方法需要使得String类能够包含标准字符串`cstring`的所有功能。

| 函数声明                                                     | 函数解释                     |
| ------------------------------------------------------------ | ---------------------------- |
| `int length () const {return len;}`                          | 用于对string类对象计数       |
| `friend bool operator<(const String &st, const String &st2);` | 友元函数，重载比较运算符     |
| `friend bool operator>(const String &st, const String &st2);` | 友元函数，重载比较运算符     |
| `friend bool operator==(const String &st, const String &st2);` | 友元函数，重载等价运算符     |
| `friend opereator >>(istream & is, String & st);`            | 友元函数，重载比较输出运算符 |
| `char & operator[](int i);`                                  | 提供了使用数组访问的方式     |
| `const char & operator[](int i) const`                       | 提供了使用数组访问的方式     |
| `static int HowMany();`                                      | 补充静态类数据成员           |



## 函数的返回对象

### 返回和构造函数

### 返回const对象的引用

### 返回对象和引用的区别

### 返回const对象